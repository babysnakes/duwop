use super::app_defaults::*;

use std::io::Write;
use std::path::Path;
use std::process::Command;

use dirs;
use failure::{format_err, Error, ResultExt};
use log::{debug, info};
use yansi::Paint;

pub fn run(skip_agent: bool) -> Result<(), Error> {
    required_directories()?;
    if !skip_agent {
        launchd_agent()?;
    }
    resolver_file()?;

    let bullet = format!("{} ", Paint::green("*"));
    let wrapper = textwrap::Wrapper::with_termwidth()
        .initial_indent(&bullet)
        .subsequent_indent("  ");
    println!("\n{}", Paint::green("================================"));
    println!("\nSetup has completed successfully\n");
    println!(
        "{}",
        wrapper.fill("use 'duwopctl completion ...' to generate shell completion")
    );
    println!(
        "{}",
        wrapper.fill("use 'duwopctl link | proxy ...' to add services")
    );
    println!(
        "{}",
        wrapper.fill("run 'duwopctl doctor' to check service, setup and db health")
    );
    println!(
        "{}",
        wrapper.fill("run 'duwopctl help' for available commands")
    );
    println!("\nEnjoy :)");
    Ok(())
}

/// A shortcut for exiting early if `Command::new(...).output()` returns with
/// non success exit status. The provided message should contain a placeholder
/// for the `stderr` content.
macro_rules! return_if_command_error {
    ($result:expr, $message:expr) => {
        if !$result.status.success() {
            return Err(format_err!(
                $message,
                std::str::from_utf8(&$result.stderr).unwrap()
            ));
        }
    };
}

/// Creates required directories. Safe to run if already exists.
fn required_directories() -> Result<(), Error> {
    info!("creating required directories");
    let home_dir = dirs::home_dir().expect("couldn't infer home directory!");
    let mut state_dir = home_dir.clone();
    state_dir.push(STATE_DIR_RELATIVE);
    let mut log_dir = home_dir.clone();
    log_dir.push(LOG_DIR);
    std::fs::create_dir_all(state_dir).context("creating state directory")?;
    std::fs::create_dir_all(log_dir).context("creating logs directory")?;
    Ok(())
}

/// Setup launchd agent, remove existing if exists.
fn launchd_agent() -> Result<(), Error> {
    info!("installing launchd agent");
    let duwop_exe = find_duwop_exe()?;
    let launchd_text = format!(r#"<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>Label</key>
    <string>{agent}</string>
    <key>ProgramArguments</key>
    <array>
      <string>{path}</string>
      <string>--launchd</string>
    </array>
    <key>Sockets</key>
    <dict>
      <key>DuwopSocket</key>
      <dict>
        <key>SockNodeName</key>
        <string>127.0.0.1</string>
        <key>SockServiceName</key>
        <string>80</string>
      </dict>
    </dict>
    <key>RunAtLoad</key>
    <true/>
  </dict>
</plist>
"#, 
        agent=AGENT_NAME,
        path=duwop_exe,
    );
    let mut launch_agents_dir = dirs::home_dir().unwrap();
    launch_agents_dir.push(&LAUNCH_AGENTS_DIR);
    debug!("creating launch agents directory: {:?}", &launch_agents_dir);
    std::fs::create_dir_all(&launch_agents_dir)?;
    let launchd_filename = format!("{}.plist", &AGENT_NAME);
    let mut launchd_file = launch_agents_dir.clone();
    launchd_file.push(&launchd_filename);
    let launchd_path = launchd_file.to_str().unwrap();
    if launchd_file.exists() {
        debug!("launchd file exists, will unload and remove");
        let unload_result = Command::new("launchctl")
            .arg("unload")
            .arg(&launchd_path)
            .output();
        debug!("unload command existed with status: {:#?}", unload_result);
    }
    let mut f = std::fs::File::create(&launchd_file)?;
    f.write_all(launchd_text.as_bytes())?;
    info!("loading {} as launchd agent", AGENT_NAME);
    let result = Command::new("launchctl")
        .arg("load")
        .arg(&launchd_path)
        .output()?;
    debug!("loading {} result: {:?}", &AGENT_NAME, &launch_agents_dir);
    return_if_command_error!(result, "failed loading service to launchd: {}");
    Ok(())
}

fn resolver_file() -> Result<(), Error> {
    info!("setting up resolver");
    let resolver_filename = format!("{}/{}", &RESOLVER_DIR, &RESOLVER_FILE);
    let resolver_file = Path::new(&resolver_filename);
    if resolver_file.exists() {
        info!(
            "resolver file ({}) already exists (possibly from previous version?). skipping.",
            &resolver_filename
        );
        return Ok(());
    }
    let content = format!(
        "# Generated by duwop\nnameserver 127.0.0.1\nport {}\n",
        &DNS_PORT
    );
    println!(
        "{} you will be prompted for your (sudo) password for creating {}",
        Paint::green("Note:"),
        &resolver_filename,
    );
    debug!("running: mkdir -p {}", &RESOLVER_DIR);
    let mkdir_result = Command::new("sudo")
        .arg("mkdir")
        .arg("-p")
        .arg(&RESOLVER_DIR)
        .output()
        .context("creating resolver directory")?;
    debug!("result: {:#?}", &mkdir_result);
    return_if_command_error!(mkdir_result, "error creating resolver directory: {}");
    let chmod_dir_result = Command::new("sudo")
        .arg("chmod")
        .arg("o+rx")
        .arg(&RESOLVER_DIR)
        .output()
        .context("changing ownership of resolver directory")?;
    debug!(
        "result for changing directory ownership: {:#?}",
        &chmod_dir_result
    );
    return_if_command_error!(
        chmod_dir_result,
        "error setting permissions on resolver directory: {}"
    );
    debug!("creating resolver file");
    let resolver_cmd = format!(r#"echo "{}" > {}"#, &content, &resolver_filename);
    let create_result = Command::new("sudo")
        .arg("sh")
        .arg("-c")
        .arg(&resolver_cmd)
        .output()
        .context("creating resolver file")?;
    debug!("result for creating resolver file: {:#?}", &create_result);
    return_if_command_error!(create_result, "error creating resolver file: {}");
    let chmod_file_result = Command::new("sudo")
        .arg("chmod")
        .arg("644")
        .arg(&resolver_filename)
        .output()
        .context("setting permissions on resolver file")?;
    debug!(
        "result for setting permissions on resolver file: {:#?}",
        &chmod_file_result
    );
    return_if_command_error!(
        chmod_file_result,
        "error setting permissions on resolver file: {}"
    );
    Ok(())
}

/// Returns the path for the _duwop_ executable.
fn find_duwop_exe() -> Result<String, Error> {
    let current_exe = std::env::current_exe().context("finding current executable")?;
    // The executable path is a symlink
    let original = current_exe
        .canonicalize()
        .context("finding duwopctl link source")?;
    let mut duwop_path = original.parent().unwrap().to_path_buf(); // only fails on "/".
    duwop_path.push("duwop");
    if duwop_path.exists() {
        Ok(duwop_path
            .to_str()
            .expect("couldn't convert duwop_path to string")
            .to_owned())
    } else {
        Err(format_err!("duwop path ({:?}) does not exist", &duwop_path))
    }
}
